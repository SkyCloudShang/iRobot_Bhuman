/**
 * The option executes a kick generated by the WalkKickEngine.
 */
option(InWalkKick)
{
  auto getKickFootOffset = [this](float phase)
  {
    Vector3f positionOffset;
    Vector3f rotationOffset;
    walkKickEngine.getState(std::min(theWalkGenerator.t / theWalkGenerator.stepDuration, 1.f),
                            positionOffset, rotationOffset);
    return Pose3f(Rotation::AngleAxis::unpack(rotationOffset), positionOffset);
  };

  initial_state(init)
  {
    walkRequest = theMotionRequest.walkRequest;

    if(playKickSounds)
      SystemCall::playSound((std::string(WalkKicks::getName(walkRequest.walkKickRequest.kickType))
                             + (walkRequest.walkKickRequest.kickLeg == Legs::left ? "Left.wav" : "Right.wav")).c_str());

    transition
    {
      if(theWalkGenerator.t == 0)
      {
        if(theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].requiresPrestep && theWalkGenerator.isLeftPhase == leftPrestepPhase)
          goto preStep;
        else if(!theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].requiresPrestep && theWalkGenerator.isLeftPhase != leftPrestepPhase)
          goto start;
      }
      goto wait;
    }
  }

  state(wait)
  {
    transition
    {
      if(theWalkGenerator.t == 0)
      {
        if(theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].requiresPrestep && theWalkGenerator.isLeftPhase == leftPrestepPhase)
          goto preStep;
        else if(!theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].requiresPrestep && theWalkGenerator.isLeftPhase != leftPrestepPhase)
          goto start;
      }
    }
    action
    {
      updateWalkRequestWithoutKick();
      Walking();
    }
  }

  state(preStep)
  {
    transition
    {
      if(theWalkGenerator.t == 0)
        goto start;
    }
    action
    {
      const Pose2f& stepSize = theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].preStepSize;
      float stepSign = theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].kickLeg == walkRequest.walkKickRequest.kickLeg ? 1.f : -1.f;
      walk(Pose2f(stepSize.rotation * stepSign, stepSize.translation.x(), stepSize.translation.y() * stepSign), WalkGenerator::stepSizeMode);
    }
  }

  state(start)
  {
    transition
    {
      goto kick;
    }
    action
    {
      walkKickEngine.start(walkRequest.walkKickRequest.kickType, walkRequest.walkKickRequest.kickLeg);
      const Pose2f& stepSize = theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].stepSize;
      float stepSign = theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].kickLeg == walkRequest.walkKickRequest.kickLeg ? 1.f : -1.f;
      walk(Pose2f(stepSize.rotation * stepSign, stepSize.translation.x(), stepSize.translation.y() * stepSign), WalkGenerator::stepSizeMode);
    }
  }

  target_state(kick)
  {
    action
    {
      const Pose2f& stepSize = theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].stepSize;
      float stepSign = theWalkKicks.kicks[walkRequest.walkKickRequest.kickType].kickLeg == walkRequest.walkKickRequest.kickLeg ? 1.f : -1.f;
      walk(Pose2f(stepSize.rotation * stepSign, stepSize.translation.x(), stepSize.translation.y() * stepSign),
           WalkGenerator::stepSizeMode, getKickFootOffset);
    }
  }
}
